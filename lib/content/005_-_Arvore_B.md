---
title: "AED III √Årvores B"
author: ""
pages: 77
source: "005_-_Arvore_B.pdf"
---

# AED III √Årvores B

√Årvores B

Roteiro

Introdu√ß√£o

Inser√ß√£o em √°rvore B

Remo√ß√£o em √°rvore B

√Årvores B

Estrutura de dados projetada para funcionar especialmente em

mem√≥ria secund√°ria (como disco magn√©tico).

Semelhante a √°rvore rubro negra, mas s√£o melhores para minimizar

opera√ß√µes de entrada e sa√≠da em disco.

Muito empregada em aplica√ß√µes que necessitam manipular grandes

quantidades de informa√ß√£o tais como um banco de dados ou um

sistema de arquivos.

Diferente das √°rvores bin√°rias, cada n√≥ pode ter muitos filhos, isto √©,

o grau de um n√≥ pode ser muito grande.

√Årvores B

Estrutura de dados projetada para funcionar especialmente em

mem√≥ria secund√°ria (como disco magn√©tico).

Semelhante a √°rvore rubro negra, mas s√£o melhores para minimizar

opera√ß√µes de entrada e sa√≠da em disco.

Muito empregada em aplica√ß√µes que necessitam manipular grandes

quantidades de informa√ß√£o tais como um banco de dados ou um

sistema de arquivos.

Diferente das √°rvores bin√°rias, cada n√≥ pode ter muitos filhos, isto √©,

o grau de um n√≥ pode ser muito grande.

√Årvores B

Estrutura de dados projetada para funcionar especialmente em

mem√≥ria secund√°ria (como disco magn√©tico).

Semelhante a √°rvore rubro negra, mas s√£o melhores para minimizar

opera√ß√µes de entrada e sa√≠da em disco.

Muito empregada em aplica√ß√µes que necessitam manipular grandes

quantidades de informa√ß√£o tais como um banco de dados ou um

sistema de arquivos.

Diferente das √°rvores bin√°rias, cada n√≥ pode ter muitos filhos, isto √©,

o grau de um n√≥ pode ser muito grande.

√Årvores B

Estrutura de dados projetada para funcionar especialmente em

mem√≥ria secund√°ria (como disco magn√©tico).

Semelhante a √°rvore rubro negra, mas s√£o melhores para minimizar

opera√ß√µes de entrada e sa√≠da em disco.

Muito empregada em aplica√ß√µes que necessitam manipular grandes

quantidades de informa√ß√£o tais como um banco de dados ou um

sistema de arquivos.

Diferente das √°rvores bin√°rias, cada n√≥ pode ter muitos filhos, isto √©,

o grau de um n√≥ pode ser muito grande.

√Årvores B

N√≥

n: n√∫mero de chaves armazenadas em um n√≥.

chaves: chaves do n√≥ em ordem crescente.

filhos ponteiros para os filhos.

folha: valor booleano que indica se o n√≥ √© uma folha.

√Årvores B

Uma √°rvore B de ordem m√≠nima t √© uma √°rvore de grau m√≠nimo t:

Caracter√≠sticas

Em um n√≥ as chaves est√£o ordenadas.

Todas as folhas est√£o no mesmo n√≠vel.

N√∫mero de filhos:

‚óÆDe t a 2 * t filhos.

‚óÆRaiz: de 2 a m filhos.

N√∫mero de chaves:

‚óÆDe t - 1 a 2 + t - 1 chaves.

‚óÆRaiz: de 1 a m - 1 chaves.

√Årvores B

Uma √°rvore B de ordem m√≠nima t √© uma √°rvore de grau m√≠nimo t:

Caracter√≠sticas

Em um n√≥ as chaves est√£o ordenadas.

Todas as folhas est√£o no mesmo n√≠vel.

N√∫mero de filhos:

‚óÆDe t a 2 * t filhos.

‚óÆRaiz: de 2 a m filhos.

N√∫mero de chaves:

‚óÆDe t - 1 a 2 + t - 1 chaves.

‚óÆRaiz: de 1 a m - 1 chaves.

√Årvores B

Uma √°rvore B de ordem m√≠nima t √© uma √°rvore de grau m√≠nimo t:

Caracter√≠sticas

Em um n√≥ as chaves est√£o ordenadas.

Todas as folhas est√£o no mesmo n√≠vel.

N√∫mero de filhos:

‚óÆDe t a 2 * t filhos.

‚óÆRaiz: de 2 a m filhos.

N√∫mero de chaves:

‚óÆDe t - 1 a 2 + t - 1 chaves.

‚óÆRaiz: de 1 a m - 1 chaves.

√Årvores B

Uma √°rvore B de ordem m√≠nima t √© uma √°rvore de grau m√≠nimo t:

Caracter√≠sticas

Em um n√≥ as chaves est√£o ordenadas.

Todas as folhas est√£o no mesmo n√≠vel.

N√∫mero de filhos:

‚óÆDe t a 2 * t filhos.

‚óÆRaiz: de 2 a m filhos.

N√∫mero de chaves:

‚óÆDe t - 1 a 2 + t - 1 chaves.

‚óÆRaiz: de 1 a m - 1 chaves.

√Årvores B

Uma √°rvore B de ordem m√≠nima t √© uma √°rvore de grau m√≠nimo t:

Caracter√≠sticas

Em um n√≥ as chaves est√£o ordenadas.

Todas as folhas est√£o no mesmo n√≠vel.

N√∫mero de filhos:

‚óÆDe t a 2 * t filhos.

‚óÆRaiz: de 2 a m filhos.

N√∫mero de chaves:

‚óÆDe t - 1 a 2 + t - 1 chaves.

‚óÆRaiz: de 1 a m - 1 chaves.

## üå≥ Ferramenta Interativa: Visualizador de √Årvore B

Experimente construir e manipular √Årvores B! Insira valores e observe como a √°rvore automaticamente divide n√≥s cheios, mantendo todas as folhas no mesmo n√≠vel. A ordem padr√£o √© 3 (no m√°ximo 3 filhos por n√≥).

```tree-btree
```

Agora que voc√™ pode visualizar as opera√ß√µes, vamos entender o algoritmo de inser√ß√£o:

## Inserindo em uma √°rvore B

Inser√ß√£o

Tente inserir a nova chave em um folha.

Se o n√∫mero de chaves do n√≥ exceder o n√∫mero de chaves permitidas,

divida a folha em duas, promovendo a chave central para o pai da

folha.

Se o n√∫mero de chaves do n√≥ pai exceder o n√∫mero de chaves

permitidas, divida o n√≥ pai em dois, promovendo a chave central para

o ancestral do pai.

Esta estrat√©gia pode ser repetida por todo caminho at√© o topo.

Se necess√°rio, a raiz √© dividida em dois n√≥s, tornando a chave central

em raiz. Se isto acontecer o n√≠vel da √°rvore aumenta.

Inserindo em uma √°rvore B

Inser√ß√£o

Tente inserir a nova chave em um folha.

Se o n√∫mero de chaves do n√≥ exceder o n√∫mero de chaves permitidas,

divida a folha em duas, promovendo a chave central para o pai da

folha.

Se o n√∫mero de chaves do n√≥ pai exceder o n√∫mero de chaves

permitidas, divida o n√≥ pai em dois, promovendo a chave central para

o ancestral do pai.

Esta estrat√©gia pode ser repetida por todo caminho at√© o topo.

Se necess√°rio, a raiz √© dividida em dois n√≥s, tornando a chave central

em raiz. Se isto acontecer o n√≠vel da √°rvore aumenta.

Inserindo em uma √°rvore B

Inser√ß√£o

Tente inserir a nova chave em um folha.

Se o n√∫mero de chaves do n√≥ exceder o n√∫mero de chaves permitidas,

divida a folha em duas, promovendo a chave central para o pai da

folha.

Se o n√∫mero de chaves do n√≥ pai exceder o n√∫mero de chaves

permitidas, divida o n√≥ pai em dois, promovendo a chave central para

o ancestral do pai.

Esta estrat√©gia pode ser repetida por todo caminho at√© o topo.

Se necess√°rio, a raiz √© dividida em dois n√≥s, tornando a chave central

em raiz. Se isto acontecer o n√≠vel da √°rvore aumenta.

Inserindo em uma √°rvore B

Inser√ß√£o

Tente inserir a nova chave em um folha.

Se o n√∫mero de chaves do n√≥ exceder o n√∫mero de chaves permitidas,

divida a folha em duas, promovendo a chave central para o pai da

folha.

Se o n√∫mero de chaves do n√≥ pai exceder o n√∫mero de chaves

permitidas, divida o n√≥ pai em dois, promovendo a chave central para

o ancestral do pai.

Esta estrat√©gia pode ser repetida por todo caminho at√© o topo.

Se necess√°rio, a raiz √© dividida em dois n√≥s, tornando a chave central

em raiz. Se isto acontecer o n√≠vel da √°rvore aumenta.

Inserindo em uma √°rvore B

Inser√ß√£o

Tente inserir a nova chave em um folha.

Se o n√∫mero de chaves do n√≥ exceder o n√∫mero de chaves permitidas,

divida a folha em duas, promovendo a chave central para o pai da

folha.

Se o n√∫mero de chaves do n√≥ pai exceder o n√∫mero de chaves

permitidas, divida o n√≥ pai em dois, promovendo a chave central para

o ancestral do pai.

Esta estrat√©gia pode ser repetida por todo caminho at√© o topo.

Se necess√°rio, a raiz √© dividida em dois n√≥s, tornando a chave central

em raiz. Se isto acontecer o n√≠vel da √°rvore aumenta.

√Årvores B

√Årvore B de grau m√≠nimo 3:

![Imagem 1](/images/005_-_Arvore_B_p18_img0.jpeg)

Construindo uma √°rvores B

Suponha que n√≥s come√ßamos com uma √°rvore B vazia e as chaves

chegam na seguinte ordem: 1, 12, 8, 2, 25, 6, 14, 28, 17, 7, 52,

16, 48, 68, 3, 26, 29, 53, 55, 45, 70, 24, 5 e 56.

N√≥s queremos construir uma √°rvore B de garu m√≠nimo 3.

Os cinco primeiras chaves v√£o para a raiz:

Colocar a sexta chave na raiz viola o n√∫mero m√°ximo de chaves por

n√≥.

Assim, quando 6 chega, pegamos a chave do meio para fazer a nova

raiz.

Construindo uma √°rvores B

Suponha que n√≥s come√ßamos com uma √°rvore B vazia e as chaves

chegam na seguinte ordem: 1, 12, 8, 2, 25, 6, 14, 28, 17, 7, 52,

16, 48, 68, 3, 26, 29, 53, 55, 45, 70, 24, 5 e 56.

N√≥s queremos construir uma √°rvore B de garu m√≠nimo 3.

Os cinco primeiras chaves v√£o para a raiz:

Colocar a sexta chave na raiz viola o n√∫mero m√°ximo de chaves por

n√≥.

Assim, quando 6 chega, pegamos a chave do meio para fazer a nova

raiz.

Construindo uma √°rvores B

Suponha que n√≥s come√ßamos com uma √°rvore B vazia e as chaves

chegam na seguinte ordem: 1, 12, 8, 2, 25, 6, 14, 28, 17, 7, 52,

16, 48, 68, 3, 26, 29, 53, 55, 45, 70, 24, 5 e 56.

N√≥s queremos construir uma √°rvore B de garu m√≠nimo 3.

Os cinco primeiras chaves v√£o para a raiz:

Colocar a sexta chave na raiz viola o n√∫mero m√°ximo de chaves por

n√≥.

Assim, quando 6 chega, pegamos a chave do meio para fazer a nova

raiz.

Construindo uma √°rvores B

Suponha que n√≥s come√ßamos com uma √°rvore B vazia e as chaves

chegam na seguinte ordem: 1, 12, 8, 2, 25, 6, 14, 28, 17, 7, 52,

16, 48, 68, 3, 26, 29, 53, 55, 45, 70, 24, 5 e 56.

N√≥s queremos construir uma √°rvore B de garu m√≠nimo 3.

Os cinco primeiras chaves v√£o para a raiz:

Colocar a sexta chave na raiz viola o n√∫mero m√°ximo de chaves por

n√≥.

Assim, quando 6 chega, pegamos a chave do meio para fazer a nova

raiz.

Construindo uma √°rvores B

Suponha que n√≥s come√ßamos com uma √°rvore B vazia e as chaves

chegam na seguinte ordem: 1, 12, 8, 2, 25, 6, 14, 28, 17, 7, 52,

16, 48, 68, 3, 26, 29, 53, 55, 45, 70, 24, 5 e 56.

N√≥s queremos construir uma √°rvore B de garu m√≠nimo 3.

Os cinco primeiras chaves v√£o para a raiz:

Colocar a sexta chave na raiz viola o n√∫mero m√°ximo de chaves por

n√≥.

Assim, quando 6 chega, pegamos a chave do meio para fazer a nova

raiz.

Construindo uma √°rvores B

1, 12, 8, 2, 25, 6, 14, 28, 17, 7, 52, 16, 48, 68, 3, 26, 29, 53,

55, 45, 70, 24, 5 e 56.

Adicionando 6 √† √°rvore.

A insers√£o de 6 excede a ordem da √°rvore, promovemos a chave

mediana.

Construindo uma √°rvores B

1, 12, 8, 2, 25, 6, 14, 28, 17, 7, 52, 16, 48, 68, 3, 26, 29, 53,

55, 45, 70, 24, 5 e 56.

Adicionando 6 √† √°rvore.

A insers√£o de 6 excede a ordem da √°rvore, promovemos a chave

mediana.

Construindo uma √°rvores B

1, 12, 8, 2, 25, 6, 14, 28, 17, 7, 52, 16, 48, 68, 3, 26, 29, 53,

55, 45, 70, 24, 5 e 56.

Adicionando 6 √† √°rvore.

A insers√£o de 6 excede a ordem da √°rvore, promovemos a chave

mediana.

Construindo uma √°rvores B

1, 12, 8, 2, 25, 6, 14, 28, 17, 7, 52, 16, 48, 68, 3, 26, 29, 53,

55, 45, 70, 24, 5 e 56.

Adicionando 14, 28, 17 e 7 √† √°rvore.

Adicionando a chave 52 √† folha direita, ter√≠amos excesso de chaves.

Promovemos o n√≥ mediano.

Construindo uma √°rvores B

1, 12, 8, 2, 25, 6, 14, 28, 17, 7, 52, 16, 48, 68, 3, 26, 29, 53,

55, 45, 70, 24, 5 e 56.

Adicionando 14, 28, 17 e 7 √† √°rvore.

Adicionando a chave 52 √† folha direita, ter√≠amos excesso de chaves.

Promovemos o n√≥ mediano.

Construindo uma √°rvores B

1, 12, 8, 2, 25, 6, 14, 28, 17, 7, 52, 16, 48, 68, 3, 26, 29, 53,

55, 45, 70, 24, 5 e 56.

Adicionando 14, 28, 17 e 7 √† √°rvore.

Adicionando a chave 52 √† folha direita, ter√≠amos excesso de chaves.

Promovemos o n√≥ mediano.

Construindo uma √°rvores B

1, 12, 8, 2, 25, 6, 14, 28, 17, 7, 52, 16, 48, 68, 3, 26, 29, 53,

55, 45, 70, 24, 5 e 56.

Adicionando 14, 28, 17 e 7 √† √°rvore.

Adicionando a chave 52 √† folha direita, ter√≠amos excesso de chaves.

Promovemos o n√≥ mediano.

Construindo uma √°rvores B

1, 12, 8, 2, 25, 6, 14, 28, 17, 7, 52, 16, 48, 68, 3, 26, 29, 53,

55, 45, 70, 24, 5 e 56.

Adicionando 14, 28, 17 e 7 √† √°rvore.

Adicionando a chave 52 √† folha direita, ter√≠amos excesso de chaves.

Promovemos o n√≥ mediano.

Construindo uma √°rvores B

1, 12, 8, 2, 25, 6, 14, 28, 17, 7, 52, 16, 48, 68, 3, 26, 29, 53,

55, 45, 70, 24, 5 e 56.

Adicionando 16, 48, 68 e 3 √† √°rvore.

Adicionando a chave 26 √† folha esquerda, ter√≠amos excesso de chaves.

Promovemos o n√≥ mediano.

Construindo uma √°rvores B

1, 12, 8, 2, 25, 6, 14, 28, 17, 7, 52, 16, 48, 68, 3, 26, 29, 53,

55, 45, 70, 24, 5 e 56.

Adicionando 16, 48, 68 e 3 √† √°rvore.

Adicionando a chave 26 √† folha esquerda, ter√≠amos excesso de chaves.

Promovemos o n√≥ mediano.

Construindo uma √°rvores B

1, 12, 8, 2, 25, 6, 14, 28, 17, 7, 52, 16, 48, 68, 3, 26, 29, 53,

55, 45, 70, 24, 5 e 56.

Adicionando 16, 48, 68 e 3 √† √°rvore.

Adicionando a chave 26 √† folha esquerda, ter√≠amos excesso de chaves.

Promovemos o n√≥ mediano.

Construindo uma √°rvores B

1, 12, 8, 2, 25, 6, 14, 28, 17, 7, 52, 16, 48, 68, 3, 26, 29, 53,

55, 45, 70, 24, 5 e 56.

Adicionando 16, 48, 68 e 3 √† √°rvore.

Adicionando a chave 26 √† folha esquerda, ter√≠amos excesso de chaves.

Promovemos o n√≥ mediano.

Construindo uma √°rvores B

1, 12, 8, 2, 25, 6, 14, 28, 17, 7, 52, 16, 48, 68, 3, 26, 29, 53,

55, 45, 70, 24, 5 e 56.

Adicionando 16, 48, 68 e 3 √† √°rvore.

Adicionando a chave 26 √† folha esquerda, ter√≠amos excesso de chaves.

Promovemos o n√≥ mediano.

Construindo uma √°rvores B

1, 12, 8, 2, 25, 6, 14, 28, 17, 7, 52, 16, 48, 68, 3, 26, 29, 53,

55, 45, 70, 24, 5 e 56.

Adicionando 26, 29, 53, 55, 45 e 70 √† √°rvore.

Adicionando a chave 24 √† folha, ter√≠amos excesso de chaves.

Promovemos o n√≥ mediano.

Construindo uma √°rvores B

1, 12, 8, 2, 25, 6, 14, 28, 17, 7, 52, 16, 48, 68, 3, 26, 29, 53,

55, 45, 70, 24, 5 e 56.

Adicionando 26, 29, 53, 55, 45 e 70 √† √°rvore.

Adicionando a chave 24 √† folha, ter√≠amos excesso de chaves.

Promovemos o n√≥ mediano.

Construindo uma √°rvores B

1, 12, 8, 2, 25, 6, 14, 28, 17, 7, 52, 16, 48, 68, 3, 26, 29, 53,

55, 45, 70, 24, 5 e 56.

Adicionando 26, 29, 53, 55, 45 e 70 √† √°rvore.

Adicionando a chave 24 √† folha, ter√≠amos excesso de chaves.

Promovemos o n√≥ mediano.

Construindo uma √°rvores B

1, 12, 8, 2, 25, 6, 14, 28, 17, 7, 52, 16, 48, 68, 3, 26, 29, 53,

55, 45, 70, 24, 5 e 56.

Adicionando 26, 29, 53, 55, 45 e 70 √† √°rvore.

Adicionando a chave 24 √† folha, ter√≠amos excesso de chaves.

Promovemos o n√≥ mediano.

Construindo uma √°rvores B

1, 12, 8, 2, 25, 6, 14, 28, 17, 7, 52, 16, 48, 68, 3, 26, 29, 53,

55, 45, 70, 24, 5 e 56.

Adicionando 26, 29, 53, 55, 45 e 70 √† √°rvore.

Adicionando a chave 24 √† folha, ter√≠amos excesso de chaves.

Promovemos o n√≥ mediano.

Construindo uma √°rvores B

1, 12, 8, 2, 25, 6, 14, 28, 17, 7, 52, 16, 48, 68, 3, 26, 29, 53,

55, 45, 70, 24, 5 e 56.

Adicionando a chave 5 √† folha, ter√≠amos excesso de chaves.

Promovemos o n√≥ mediano.

Adicionando a chave 56 √† folha, ter√≠amos excesso de chaves.

Promovemos o n√≥ mediano.

A inser√ß√£o fez com que a altura da √°rvore aumentasse.

Construindo uma √°rvores B

1, 12, 8, 2, 25, 6, 14, 28, 17, 7, 52, 16, 48, 68, 3, 26, 29, 53,

55, 45, 70, 24, 5 e 56.

Adicionando a chave 5 √† folha, ter√≠amos excesso de chaves.

Promovemos o n√≥ mediano.

Adicionando a chave 56 √† folha, ter√≠amos excesso de chaves.

Promovemos o n√≥ mediano.

A inser√ß√£o fez com que a altura da √°rvore aumentasse.

Construindo uma √°rvores B

1, 12, 8, 2, 25, 6, 14, 28, 17, 7, 52, 16, 48, 68, 3, 26, 29, 53,

55, 45, 70, 24, 5 e 56.

Adicionando a chave 5 √† folha, ter√≠amos excesso de chaves.

Promovemos o n√≥ mediano.

Adicionando a chave 56 √† folha, ter√≠amos excesso de chaves.

Promovemos o n√≥ mediano.

A inser√ß√£o fez com que a altura da √°rvore aumentasse.

Construindo uma √°rvores B

1, 12, 8, 2, 25, 6, 14, 28, 17, 7, 52, 16, 48, 68, 3, 26, 29, 53,

55, 45, 70, 24, 5 e 56.

Adicionando a chave 5 √† folha, ter√≠amos excesso de chaves.

Promovemos o n√≥ mediano.

Adicionando a chave 56 √† folha, ter√≠amos excesso de chaves.

Promovemos o n√≥ mediano.

A inser√ß√£o fez com que a altura da √°rvore aumentasse.

Construindo uma √°rvores B

1, 12, 8, 2, 25, 6, 14, 28, 17, 7, 52, 16, 48, 68, 3, 26, 29, 53,

55, 45, 70, 24, 5 e 56.

Adicionando a chave 5 √† folha, ter√≠amos excesso de chaves.

Promovemos o n√≥ mediano.

Adicionando a chave 56 √† folha, ter√≠amos excesso de chaves.

Promovemos o n√≥ mediano.

A inser√ß√£o fez com que a altura da √°rvore aumentasse.

Construindo uma √°rvores B

1, 12, 8, 2, 25, 6, 14, 28, 17, 7, 52, 16, 48, 68, 3, 26, 29, 53,

55, 45, 70, 24, 5 e 56.

Adicionando a chave 5 √† folha, ter√≠amos excesso de chaves.

Promovemos o n√≥ mediano.

Adicionando a chave 56 √† folha, ter√≠amos excesso de chaves.

Promovemos o n√≥ mediano.

A inser√ß√£o fez com que a altura da √°rvore aumentasse.

Aplica√ß√£o

1 Insira as seguintes chaves em uma √°rvore B de grau m√≠nimo 3: 3, 7,

9, 23, 45, 1, 5, 14, 25, 24, 13, 11, 8, 19, 4, 31, 35, 56, 15, 60, 16, 20

e 22.

Split

Fun√ß√£o respons√°vel por dividir um n√≥ cheio.

A fun√ß√£o recebe como par√¢metros x e i:

‚óÆx: n√≥ interno n√£o cheio.

‚óÆi: √≠ndice de um filho de x, tal que x.filhos[i] √© um n√≥ cheio.

A fun√ß√£o reparte o filho de x em dois e ajusta x de forma que ele

tenha uma chave adicional.

Split

Fun√ß√£o respons√°vel por dividir um n√≥ cheio.

A fun√ß√£o recebe como par√¢metros x e i:

‚óÆx: n√≥ interno n√£o cheio.

‚óÆi: √≠ndice de um filho de x, tal que x.filhos[i] √© um n√≥ cheio.

A fun√ß√£o reparte o filho de x em dois e ajusta x de forma que ele

tenha uma chave adicional.

Split

Fun√ß√£o respons√°vel por dividir um n√≥ cheio.

A fun√ß√£o recebe como par√¢metros x e i:

‚óÆx: n√≥ interno n√£o cheio.

‚óÆi: √≠ndice de um filho de x, tal que x.filhos[i] √© um n√≥ cheio.

A fun√ß√£o reparte o filho de x em dois e ajusta x de forma que ele

tenha uma chave adicional.

Split

Fun√ß√£o respons√°vel por dividir um n√≥ cheio.

A fun√ß√£o recebe como par√¢metros x e i:

‚óÆx: n√≥ interno n√£o cheio.

‚óÆi: √≠ndice de um filho de x, tal que x.filhos[i] √© um n√≥ cheio.

A fun√ß√£o reparte o filho de x em dois e ajusta x de forma que ele

tenha uma chave adicional.

Split

B-TREE-SPLIT(x, i) {

z = ALLOCATE-NODE();

y = x.filhos[i];

// filho de x

z.folha = y.folha;

// z folha, se y folha

z.n = t - 1;

// z tem o m√≠nimo de chaves

for j = 1 to t - 1

// copia chaves de y para z

z.chaves[j] = y.chaves[j + t];

if not y.folha

for j = 1 to t

// copia filhos de y para z

z.filhos[j] = y.filhos[j + t];

y.n = t - 1;

// y tem o m√≠nimo de chaves

Split

for j = x.n + 1 downto i + 1

// desloca filhos de x

x.filhos[j + 1] = x.filhos[j];

x.filhos[i + 1] = z;

// faz x apontar para z

for j = x.n downto i

// desloca chaves de x

x.chaves[j + 1] = x.chaves[j];

x.chaves[i] = y.chaves[t];

// inclui nova chave em x

x.n = x.n + 1;

DISK-WRITE(y);

DISK-WRITE(z);

DISK-WRITE(x);

}

Inser√ß√£o

A fun√ß√£o de inser√ß√£o recebe a raiz da √°rvore, T, e a chave a ser

inserida, k.

B-TREE-INSERT(T, k) {

r = T;

if r.n == 2t -1

// raiz cheia

s = ALLOCATE-NODE();

T = s;

s.folha = false;

s.n = 0;

s.filhos[1] = r;

B-TREE-SPLIT(s, 1);

B-TREE-INSERT-NONFULL(s, k);

else

B-TREE-INSERT-NONFULL(r, k);

}

Inser√ß√£o

A fun√ß√£o auxiliar de inser√ß√£o recebe um n√≥ x e a chave k a ser

inserida.

A inser√ß√£o √© feita nas folhas. Assim, a fun√ß√£o percorre a √°rvore (de

forma recursiva) at√© encontrar uma folha para a inser√ß√£o.

B-TREE-INSERT-NONFULL(x, k) {

i = x.n;

if x.folha

// desloca chaves do n√≥ para abrir espa√ßo

while i >= 1 e k < x.chaves[i]

x.chaves[i + 1] = x.chaves[i];

i = i - 1;

// insere a nova chave

x.chaves[i + 1] = k;

x.n = x.n + 1;

DISK-WRITE(x);

Inser√ß√£o

A fun√ß√£o auxiliar de inser√ß√£o recebe um n√≥ x e a chave k a ser

inserida.

A inser√ß√£o √© feita nas folhas. Assim, a fun√ß√£o percorre a √°rvore (de

forma recursiva) at√© encontrar uma folha para a inser√ß√£o.

B-TREE-INSERT-NONFULL(x, k) {

i = x.n;

if x.folha

// desloca chaves do n√≥ para abrir espa√ßo

while i >= 1 e k < x.chaves[i]

x.chaves[i + 1] = x.chaves[i];

i = i - 1;

// insere a nova chave

x.chaves[i + 1] = k;

x.n = x.n + 1;

DISK-WRITE(x);

Inser√ß√£o

A fun√ß√£o auxiliar de inser√ß√£o recebe um n√≥ x e a chave k a ser

inserida.

A inser√ß√£o √© feita nas folhas. Assim, a fun√ß√£o percorre a √°rvore (de

forma recursiva) at√© encontrar uma folha para a inser√ß√£o.

B-TREE-INSERT-NONFULL(x, k) {

i = x.n;

if x.folha

// desloca chaves do n√≥ para abrir espa√ßo

while i >= 1 e k < x.chaves[i]

x.chaves[i + 1] = x.chaves[i];

i = i - 1;

// insere a nova chave

x.chaves[i + 1] = k;

x.n = x.n + 1;

DISK-WRITE(x);

Inser√ß√£o

A fun√ß√£o auxiliar de inser√ß√£o recebe um n√≥ x e a chave k a ser

inserida.

A inser√ß√£o √© feita nas folhas. Assim, a fun√ß√£o percorre a √°rvore (de

forma recursiva) at√© encontrar uma folha para a inser√ß√£o.

B-TREE-INSERT-NONFULL(x, k) {

i = x.n;

if x.folha

// desloca chaves do n√≥ para abrir espa√ßo

while i >= 1 e k < x.chaves[i]

x.chaves[i + 1] = x.chaves[i];

i = i - 1;

// insere a nova chave

x.chaves[i + 1] = k;

x.n = x.n + 1;

DISK-WRITE(x);

Inser√ß√£o

else

// encontra filho para inser√ß√£o

while i >= 1 e k < x.chaves[i]

i = i - 1;

i = i + 1;

DISK-READ(x.filhos[i]);

// se n√≥ do filho estiver cheio

if x.filhos[i].n == 2t - 1

B-TREE-SPLIT(x, i);

// define o n√≥ da inser√ß√£o

if k > x.chaves[i]

i = i + 1;

B-TREE-INSERT-NONFULL(x.filhos[i], k);

}

Remo√ß√£o

Durante a inser√ß√£o, a nova chave √© inserida sempre em um n√≥ folha.

Para a exclus√£o temos quatro casos poss√≠veis:

‚óÆCaso 1: Se a chave a ser removida est√° em um n√≥ folha e remov√™-la

n√£o faz com que o n√≥ Ô¨Åque com menos que o n√∫mero m√≠nimo de

chaves permitidas, podemos remover a chave.

‚óÆCaso 2: Se a chave a ser removida n√£o est√° em uma folha ent√£o √©

garantido que seu antecessor ou sucessor est√° em uma folha. Neste

caso, podemos excluir a chave e promover a chave antecessora ou

sucessora para a posi√ß√£o da chave removida.

Remo√ß√£o

Durante a inser√ß√£o, a nova chave √© inserida sempre em um n√≥ folha.

Para a exclus√£o temos quatro casos poss√≠veis:

‚óÆCaso 1: Se a chave a ser removida est√° em um n√≥ folha e remov√™-la

n√£o faz com que o n√≥ Ô¨Åque com menos que o n√∫mero m√≠nimo de

chaves permitidas, podemos remover a chave.

‚óÆCaso 2: Se a chave a ser removida n√£o est√° em uma folha ent√£o √©

garantido que seu antecessor ou sucessor est√° em uma folha. Neste

caso, podemos excluir a chave e promover a chave antecessora ou

sucessora para a posi√ß√£o da chave removida.

Remo√ß√£o

Durante a inser√ß√£o, a nova chave √© inserida sempre em um n√≥ folha.

Para a exclus√£o temos quatro casos poss√≠veis:

‚óÆCaso 1: Se a chave a ser removida est√° em um n√≥ folha e remov√™-la

n√£o faz com que o n√≥ Ô¨Åque com menos que o n√∫mero m√≠nimo de

chaves permitidas, podemos remover a chave.

‚óÆCaso 2: Se a chave a ser removida n√£o est√° em uma folha ent√£o √©

garantido que seu antecessor ou sucessor est√° em uma folha. Neste

caso, podemos excluir a chave e promover a chave antecessora ou

sucessora para a posi√ß√£o da chave removida.

Remo√ß√£o

Se os casos 1 ou 2 levam a um n√≥ folha que cont√©m menos que o

n√∫mero m√≠nimo de chaves, ent√£o temos que ver os irm√£os

imediatamente adjacentes √† folha em quest√£o:

‚óÆCaso 3: Se um deles tem mais que o n√∫mero m√≠nimo de chaves, ent√£o

n√≥s podemos promover uma de suas chaves para o pai e tomar a chave

pai em folha.

‚óÆCaso 4: Se nenhum deles tem mais que o n√∫mero de m√≠nimo de

chaves, as folhas podem ser combinadas com seu pai (o oposto da

promo√ß√£o de uma chave) e a nova folha ter√° o n√∫mero correto de

chaves. Se este passo deixar o progenitor com muito poucas chaves,

repita o processo at√© a raiz, se necess√°rio.

Remo√ß√£o

Se os casos 1 ou 2 levam a um n√≥ folha que cont√©m menos que o

n√∫mero m√≠nimo de chaves, ent√£o temos que ver os irm√£os

imediatamente adjacentes √† folha em quest√£o:

‚óÆCaso 3: Se um deles tem mais que o n√∫mero m√≠nimo de chaves, ent√£o

n√≥s podemos promover uma de suas chaves para o pai e tomar a chave

pai em folha.

‚óÆCaso 4: Se nenhum deles tem mais que o n√∫mero de m√≠nimo de

chaves, as folhas podem ser combinadas com seu pai (o oposto da

promo√ß√£o de uma chave) e a nova folha ter√° o n√∫mero correto de

chaves. Se este passo deixar o progenitor com muito poucas chaves,

repita o processo at√© a raiz, se necess√°rio.

Remo√ß√£o

Se os casos 1 ou 2 levam a um n√≥ folha que cont√©m menos que o

n√∫mero m√≠nimo de chaves, ent√£o temos que ver os irm√£os

imediatamente adjacentes √† folha em quest√£o:

‚óÆCaso 3: Se um deles tem mais que o n√∫mero m√≠nimo de chaves, ent√£o

n√≥s podemos promover uma de suas chaves para o pai e tomar a chave

pai em folha.

‚óÆCaso 4: Se nenhum deles tem mais que o n√∫mero de m√≠nimo de

chaves, as folhas podem ser combinadas com seu pai (o oposto da

promo√ß√£o de uma chave) e a nova folha ter√° o n√∫mero correto de

chaves. Se este passo deixar o progenitor com muito poucas chaves,

repita o processo at√© a raiz, se necess√°rio.

Caso 1: Remo√ß√£o Simples

Assumindo uma √°rvore B de grau m√≠nimo 3:

Removendo a chave 2.

Caso 1: Remo√ß√£o Simples

Assumindo uma √°rvore B de grau m√≠nimo 3:

Remove 2: as chaves s√£o suficiente, basta remover.

Caso 2: Remo√ß√£o de um n√≥ interno

Removendo a chave 52.

Caso 2: Remo√ß√£o de um n√≥ interno

Remove 52: 52 √© um n√≥ interno, tomamos o sucessor emprestado.

Caso 4: Poucas chaves nos n√≥s irm√£os

Removendo a chave 72.

Caso 4: Poucas chaves nos n√≥s irm√£os

Remove 72: como h√° poucas chaves juntamos as chaves formando um

novo n√≥.

Caso 4: Poucas chaves nos n√≥s irm√£os

√Årvore resultante:

Caso 3: Irm√£os suficientes

Removendo a chave 22.

Caso 3: Irm√£os suficientes

Remove 22: como os irm√£os s√£o suficientes, rebaixa a chave raiz e

promove a chave folha.

Caso 3: Irm√£os suficientes

√Årvore resultante:

Aplica√ß√£o

1 Dada a √°rvore B de grau m√≠nimo 3 do √∫ltimo exerc√≠cio: 3, 7, 9, 23,

45, 1, 5, 14, 25, 24, 13, 11, 8, 19, 4, 31, 35, 56, 15, 60, 16, 20 e 22.

Remova as chaves 4, 5, 7, 3 e 14.

